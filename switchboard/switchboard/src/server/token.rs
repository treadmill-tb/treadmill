//! Facilities for managing API tokens.

use base64::prelude::BASE64_STANDARD_NO_PAD;
use base64::Engine;
use chrono::{DateTime, Utc};
use headers::Header;
use http::{HeaderName, HeaderValue};
use serde::{Deserialize, Serialize};
use serde_with::base64::Base64;
use serde_with::serde_as;
use sqlx::PgExecutor;
use std::fmt::{Display, Formatter};
use subtle::ConstantTimeEq;
use thiserror::Error;
use uuid::Uuid;

// TODO: Decision: fold XApiToken into ApiToken?

/// [`axum_extra::TypedHeader`]-compatible custom API token header.
///
/// The header is of the form
/// ```http
/// tml-api-token: "<base64-unpadded token goes here>"
/// ```
///
/// As per the recommendation of [RFC6648](https://www.rfc-editor.org/rfc/rfc6648#section-3.3),
/// we do _not_ use the `X-` prefix.
/// As per [RFC7540](https://www.rfc-editor.org/rfc/rfc7540#section-8.1.2), "header field names MUST
/// be converted to lowercase prior to their encoding in HTTP/2"; this is also specified by the
/// [`headers`] crate for HTTP/2 ease of use, so we will everywhere refer to it in all-lowercase
/// form, even though HTTP/1 is case-insensitive to header field names and often displays them in
/// `Screaming-Lisp-Case`.
///
/// Implements [`http::Header].
#[derive(Debug, Serialize, Deserialize)]
#[serde(transparent)]
pub struct XApiToken(pub ApiToken);
impl From<XApiToken> for ApiToken {
    fn from(value: XApiToken) -> Self {
        value.0
    }
}
impl From<ApiToken> for XApiToken {
    fn from(value: ApiToken) -> Self {
        XApiToken(value)
    }
}
impl Header for XApiToken {
    fn name() -> &'static HeaderName {
        static HEADER_NAME: HeaderName = HeaderName::from_static("tml-api-token");
        &HEADER_NAME
    }
    fn decode<'i, I>(values: &mut I) -> Result<Self, headers::Error>
    where
        Self: Sized,
        I: Iterator<Item = &'i HeaderValue>,
    {
        let value = values.next().ok_or_else(headers::Error::invalid)?;
        let value_str = value.to_str().map_err(|e| {
            tracing::error!(
                "Failed to parsex-api-token: field value has non-ASCII characters: {e}"
            );
            headers::Error::invalid()
        })?;
        let api_token: ApiToken = serde_json::from_str(value_str).map_err(|e| {
            tracing::error!("Failed to parse x-api-token: {e}");
            headers::Error::invalid()
        })?;
        Ok(Self(api_token))
    }
    fn encode<E: Extend<HeaderValue>>(&self, values: &mut E) {
        values.extend(std::iter::once(
            HeaderValue::from_str(serde_json::to_string(&self.0).unwrap().as_str()).unwrap(),
        ));
    }
}

/// An API token is a 128-byte string generated by a cryptographically secure PRNG.
///
/// On the wire, it is represented as a standard, unpadded base-64 string.
///
/// Equality testing is provided via [`Eq`] and [`PartialEq`], and implemented with
/// [`subtle::ConstantTimeEq`] to mitigate timing attacks.
// Use `serde_with::serde_as` since `serde` by itself doesn't support arrays larger than 32 items,
// and also because `serde_with` has builtin base64-encoding support.
#[serde_as]
#[derive(Debug, Serialize, Deserialize, Eq, Copy, Clone)]
pub struct ApiToken(#[serde_as(as = "Base64")] [u8; 128]);
impl ApiToken {
    /// Generate a random new ApiToken.
    ///
    /// Since this is a bit more than 8 times wider than a v4 UUID (122 bits), collisions are next
    /// to impossible.
    ///
    /// Uses [`rand::ThreadRng`] under the hood.
    pub fn generate() -> Self {
        Self(rand::random())
    }

    /// Get access to an immutable byte representation of the token.
    pub fn as_bytes(&self) -> &[u8] {
        &self.0
    }
}
impl PartialEq for ApiToken {
    fn eq(&self, other: &Self) -> bool {
        // IMPORTANT: use ConstantTimeEq to mitigate possible timing attacks:
        // [`subtle::ConstantTimeEq`] is implemented for [u8] so this is sufficient
        self.0.ct_eq(&other.0).into()
    }
}
impl TryFrom<Vec<u8>> for ApiToken {
    type Error = Vec<u8>;

    fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
        Ok(Self(value.try_into()?))
    }
}
impl Display for ApiToken {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str(&BASE64_STANDARD_NO_PAD.encode(&self.0))
    }
}

/// Errors that may occur while trying to work with API tokens.
#[derive(Debug, Error)]
pub enum TokenError {
    /// A supplied token was invalid.
    #[error("invalid token")]
    InvalidToken,
    /// An error occurred in the database (this does NOT include e.g. situations where a row is
    /// expected but not found; rather, it covers situations where the database failed on its own).
    #[error("database error: {0}")]
    Database(sqlx::Error),
}

/// Corresponds to the `cancellation` type in the database schema.
///
/// Represents the time and reason for the revocation of an API token.
#[derive(Debug, sqlx::Type)]
#[sqlx(type_name = "cancellation")]
pub struct Cancellation {
    pub canceled_at: DateTime<Utc>,
    pub cancellation_reason: String,
}
impl Display for Cancellation {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "canceled at `{}` due to `{}`",
            self.canceled_at, self.cancellation_reason
        )
    }
}

/// Minimal information about a token.
#[derive(Debug)]
pub struct TokenInfoBare {
    /// The token ID (which is NOT the secret 128-byte token itself, but rather the label of that
    /// token within the system).
    pub token_id: Uuid,
    /// If this is `Some`, then the token was at some prior time revoked; the information inside the
    /// [`Cancellation`] describes the precise time and circumstance.
    pub canceled: Option<Cancellation>,
    /// The time at which the token expires/expiree.
    pub expires_at: DateTime<Utc>,
}
/// Look up a token by its secret in the database.
pub async fn token_lookup<'c, E: PgExecutor<'c>>(
    conn: E,
    token: ApiToken,
) -> Result<TokenInfoBare, TokenError> {
    sqlx::query_as!(
        TokenInfoBare,
        // need `as "canceled: _"` for weird SQLx reasons
        r#"SELECT token_id, canceled as "canceled: _", expires_at FROM api_tokens WHERE token = $1 LIMIT 1;"#,
        &token.0,
    )
    .fetch_one(conn)
    .await
    .map_err(|e| match e {
        sqlx::Error::RowNotFound => TokenError::InvalidToken,
        e => TokenError::Database(e),
    })
}
