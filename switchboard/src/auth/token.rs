//! Facilities for managing API tokens.

use base64::Engine;
use base64::prelude::BASE64_STANDARD;
use headers::authorization::Bearer;
use serde::{Deserialize, Serialize};
use std::fmt::{Display, Formatter};
use subtle::{Choice, ConstantTimeEq};
use thiserror::Error;
use treadmill_rs::api::switchboard::AuthToken;

/// A security token is a 128-byte string generated by a cryptographically secure PRNG.
///
/// On the wire, it is represented as a standard, unpadded base-64 string.
///
/// Equality testing is provided via [`Eq`] and [`PartialEq`], and implemented with
/// [`subtle::ConstantTimeEq`] to mitigate timing attacks. (Note that the `Eq` and `PartialEq`
/// implementations both use `ConstantTimeEq` internally.)
#[derive(Debug, Serialize, Deserialize, Eq, PartialEq, Copy, Clone)]
#[serde(transparent)]
pub struct SecurityToken(AuthToken);
impl From<SecurityToken> for AuthToken {
    fn from(val: SecurityToken) -> Self {
        val.0
    }
}
impl SecurityToken {
    /// Generate a random new ApiToken.
    ///
    /// Since this is a bit more than 8 times wider than a v4 UUID (122 bits), collisions are next
    /// to impossible.
    ///
    /// Uses [`rand::ThreadRng`] under the hood.
    pub fn generate() -> Self {
        Self(AuthToken(rand::random()))
    }

    /// Get access to an immutable byte representation of the token.
    pub fn as_bytes(&self) -> &[u8] {
        &self.0.0
    }
}
impl ConstantTimeEq for SecurityToken {
    fn ct_eq(&self, other: &Self) -> Choice {
        self.0.ct_eq(&other.0)
    }
}
impl TryFrom<Vec<u8>> for SecurityToken {
    type Error = <[u8; 32] as TryFrom<Vec<u8>>>::Error;

    fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
        Ok(Self(AuthToken(value.try_into()?)))
    }
}
#[derive(Debug, Error)]
pub enum HttpDecodeError {
    #[error("Error decoding base64 string: {0}")]
    Base64(base64::DecodeError),
    #[error("Expected token to be byte string of length 128")]
    Length,
}
impl TryFrom<Bearer> for SecurityToken {
    type Error = HttpDecodeError;

    fn try_from(value: Bearer) -> Result<Self, Self::Error> {
        let v = BASE64_STANDARD
            .decode(value.token())
            .map_err(HttpDecodeError::Base64)?;
        let a: [u8; 128] = v.try_into().map_err(|_| HttpDecodeError::Length)?;
        Ok(Self(AuthToken(a)))
    }
}
impl Display for SecurityToken {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str(&BASE64_STANDARD.encode(self.0.0))
    }
}
